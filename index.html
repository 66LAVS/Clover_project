<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Clover Mission Planner</title>
  <link rel="icon" type="image/png" href="logo.png" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    :root {
      --bg: #0b0f14;
      --card: #121922;
      --line: #263242;
      --text: #dce6f3;
      --muted: #95a6ba;
      --accent: #2c8cff;
      --danger: #e0565b;
      --ok: #57c487;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, Segoe UI, Arial, sans-serif;
    }
    header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      position: sticky;
      top: 0;
      background: rgba(11,15,20,.95);
      backdrop-filter: blur(8px);
      z-index: 5;
    }
    .status { font-size: 13px; color: var(--muted); }
    .status b { color: var(--text); }
    .layout {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 14px;
      padding: 14px;
      height: calc(100vh - 62px);
    }
    .panel {
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-right: 4px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
    }
    h3 { margin: 0 0 10px; font-size: 16px; }
    label {
      font-size: 12px;
      color: var(--muted);
      margin: 8px 0 4px;
      display: block;
    }
    input, select, button {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: #0d141d;
      color: var(--text);
    }
    button {
      background: var(--accent);
      border-color: var(--accent);
      font-weight: 600;
      cursor: pointer;
      margin-top: 8px;
    }
    button.secondary {
      background: #1a2431;
      border-color: var(--line);
    }
    button.danger {
      background: var(--danger);
      border-color: var(--danger);
    }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .row { display: flex; gap: 8px; }
    .map-wrap {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 0;
    }
    #map { height: 100%; min-height: 420px; border-radius: 10px; overflow: hidden; }
    .hint { font-size: 12px; color: var(--muted); line-height: 1.35; }
    .points-list {
      font-size: 12px;
      color: var(--muted);
      max-height: 165px;
      overflow: auto;
      border: 1px dashed var(--line);
      border-radius: 8px;
      padding: 8px;
      line-height: 1.45;
      background: #0d141d;
    }
    #log {
      background: #0d141d;
      border: 1px solid var(--line);
      border-radius: 8px;
      height: 170px;
      overflow: auto;
      padding: 8px;
      font-family: Consolas, monospace;
      font-size: 12px;
      color: #bcd0e7;
    }
    @media (max-width: 1000px) {
      .layout { grid-template-columns: 1fr; height: auto; }
      #map { min-height: 360px; }
    }
  </style>
</head>
<body>
  <header>
    <div><b>Clover Mission Planner</b> · полёт по траектории Alpine Quest</div>
    <div class="status" id="topStatus">Статус: <b>Отключено</b></div>
  </header>

  <div class="layout">
    <section class="panel">
      <div class="card">
        <h3>1) Подключение</h3>
        <label>ROS Bridge (WebSocket)</label>
        <input id="rosUrl" value="ws://192.168.11.1:9090" />
        <div class="row">
          <button onclick="connectRos()">Подключиться</button>
          <button class="secondary" onclick="disconnectRos()">Отключить</button>
        </div>
      </div>

      <div class="card">
        <h3>2) Параметры миссии</h3>
        <label>Высота полёта (м)</label>
        <input id="cruiseAlt" type="number" step="0.1" value="12" />

        <label>Скорость полёта (м/с)</label>
        <input id="cruiseSpeed" type="number" step="0.1" value="3" />

        <label>Высота снижения в конечной точке (м)</label>
        <input id="descentAlt" type="number" step="0.1" value="3" />

        <label>Скорость снижения (м/с)</label>
        <input id="descentSpeed" type="number" step="0.1" value="1" />

        <label>Действие в конечной точке</label>
        <select id="endAction">
          <option value="drop_continue">Команда оператору: сброс, затем возврат</option>
          <option value="manual_stop">Переход на ручное управление и стоп миссии</option>
        </select>

        <label>После возврата</label>
        <select id="afterReturn">
          <option value="hover">Зависнуть в последней точке</option>
          <option value="land">Посадка</option>
        </select>
      </div>

      <div class="card">
        <h3>3) Маршрут (5 промежуточных + конечная)</h3>
        <p class="hint">Клик по карте: сначала ставятся точки WP1..WP5, затем END. Импорт из Alpine Quest — GPX.</p>
        <input id="gpxFile" type="file" accept=".gpx,application/gpx+xml,application/xml,text/xml" />
        <div class="row">
          <button class="secondary" onclick="importGpx()">Импорт GPX</button>
          <button class="secondary" onclick="clearRoute()">Очистить</button>
        </div>
        <button class="secondary" onclick="buildRoundTripVisual()">Построить туда-обратно (визуально)</button>
        <div class="points-list" id="pointsList">Точки ещё не заданы.</div>
      </div>

      <div class="card">
        <h3>4) Миссия</h3>
        <div class="row">
          <button onclick="startMission()">Старт миссии</button>
          <button class="danger" onclick="stopMission('Остановлено оператором')">Стоп миссии</button>
        </div>
        <button class="secondary" onclick="continueAfterOperatorAction()">Продолжить после действия оператора</button>
        <button class="danger" onclick="emergencyLand()">Аварийная посадка</button>
      </div>

      <div class="card">
        <h3>Телеметрия / безопасность</h3>
        <div class="hint" id="telemetryBox">
          GPS: —<br>
          Fix: —<br>
          Режим: —<br>
          Миссия: —
        </div>
      </div>

      <div class="card">
        <h3>Журнал</h3>
        <div id="log"></div>
      </div>
    </section>

    <section class="map-wrap">
      <div class="hint">
        Карта OSM. Сценарий миссии: <b>взлёт → WP1..WP5 → END (снижение) → обратный путь WP5..WP1</b>.<br>
        При потере GPS: миссия останавливается, выполняется переход на ручное управление.
      </div>
      <div id="map"></div>
    </section>
  </div>

  <script>
    let socket = null;
    let map, routeLine = null;
    let waypointMarkers = [];
    let endMarker = null;
    let reverseLine = null;

    const state = {
      waypoints: [], // [{lat, lon}] ровно 5
      endPoint: null, // {lat, lon}
      currentGps: null, // {lat, lon, alt}
      gpsFixStatus: null,
      flightMode: '—',
      lastGpsFixTimestamp: 0,
      mission: {
        running: false,
        stopRequested: false,
        waitingOperator: false,
        operatorContinueResolver: null,
        step: 'idle'
      }
    };

    function log(msg) {
      const el = document.getElementById('log');
      const t = new Date().toLocaleTimeString();
      el.innerHTML += `[${t}] ${msg}<br>`;
      el.scrollTop = el.scrollHeight;
      refreshTelemetryBox();
    }

    function setTopStatus(text) {
      document.getElementById('topStatus').innerHTML = `Статус: <b>${text}</b>`;
    }

    function refreshTelemetryBox() {
      const g = state.currentGps;
      const gpsText = g ? `${g.lat.toFixed(6)}, ${g.lon.toFixed(6)}, alt ${g.alt.toFixed(1)} м` : '—';
      const fix = state.gpsFixStatus === null ? '—' : state.gpsFixStatus;
      document.getElementById('telemetryBox').innerHTML =
        `GPS: ${gpsText}<br>` +
        `Fix: ${fix}<br>` +
        `Режим: ${state.flightMode}<br>` +
        `Миссия: ${state.mission.step}`;
    }

    function initMap() {
      map = L.map('map').setView([55.75, 37.62], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);

      map.on('click', (e) => {
        const p = { lat: e.latlng.lat, lon: e.latlng.lng };

        if (state.waypoints.length < 5) {
          state.waypoints.push(p);
          log(`Добавлена промежуточная точка WP${state.waypoints.length}`);
        } else if (!state.endPoint) {
          state.endPoint = p;
          log('Добавлена конечная точка END');
        } else {
          log('Маршрут уже заполнен: 5 промежуточных + END. Нажмите "Очистить".');
          return;
        }

        redrawRoute();
      });
    }

    function redrawRoute() {
      waypointMarkers.forEach(m => map.removeLayer(m));
      waypointMarkers = [];
      if (endMarker) { map.removeLayer(endMarker); endMarker = null; }
      if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
      if (reverseLine) { map.removeLayer(reverseLine); reverseLine = null; }

      state.waypoints.forEach((p, i) => {
        const marker = L.marker([p.lat, p.lon]).addTo(map).bindTooltip(`WP${i + 1}`, { permanent: true, direction: 'top' });
        waypointMarkers.push(marker);
      });

      if (state.endPoint) {
        endMarker = L.marker([state.endPoint.lat, state.endPoint.lon]).addTo(map).bindTooltip('END', { permanent: true, direction: 'top' });
      }

      const forward = state.waypoints.map(p => [p.lat, p.lon]);
      if (state.endPoint) forward.push([state.endPoint.lat, state.endPoint.lon]);
      if (forward.length >= 2) routeLine = L.polyline(forward, { color: '#2c8cff', weight: 3 }).addTo(map);

      updatePointsList();
    }

    function buildRoundTripVisual() {
      if (reverseLine) { map.removeLayer(reverseLine); reverseLine = null; }
      if (state.waypoints.length !== 5 || !state.endPoint) {
        log('Нужно ровно 5 промежуточных точек и 1 конечная.');
        return;
      }
      const back = [...state.waypoints].reverse().map(p => [p.lat, p.lon]);
      const route = [[state.endPoint.lat, state.endPoint.lon], ...back];
      reverseLine = L.polyline(route, { color: '#57c487', dashArray: '6,6', weight: 3 }).addTo(map);
      log('Показан обратный маршрут по тем же точкам.');
    }

    function clearRoute() {
      state.waypoints = [];
      state.endPoint = null;
      redrawRoute();
      log('Маршрут очищен.');
    }

    function updatePointsList() {
      const el = document.getElementById('pointsList');
      if (!state.waypoints.length && !state.endPoint) {
        el.innerHTML = 'Точки ещё не заданы.';
        return;
      }
      let html = '';
      state.waypoints.forEach((p, i) => {
        html += `WP${i+1}: ${p.lat.toFixed(6)}, ${p.lon.toFixed(6)}<br>`;
      });
      if (state.endPoint) html += `<b>END:</b> ${state.endPoint.lat.toFixed(6)}, ${state.endPoint.lon.toFixed(6)}`;
      el.innerHTML = html;
    }

    function importGpx() {
      const f = document.getElementById('gpxFile').files[0];
      if (!f) { log('Выберите GPX файл.'); return; }

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const xml = new DOMParser().parseFromString(reader.result, 'application/xml');
          const trkpts = [...xml.querySelectorAll('trkpt')].map(n => ({ lat: parseFloat(n.getAttribute('lat')), lon: parseFloat(n.getAttribute('lon')) }));
          const wpts = [...xml.querySelectorAll('wpt')].map(n => ({ lat: parseFloat(n.getAttribute('lat')), lon: parseFloat(n.getAttribute('lon')) }));
          const pts = trkpts.length ? trkpts : wpts;

          if (pts.length < 6) {
            log('В GPX нужно минимум 6 точек: 5 промежуточных + конечная.');
            return;
          }

          state.waypoints = pts.slice(0, 5);
          state.endPoint = pts[5];
          redrawRoute();
          map.fitBounds(L.latLngBounds(pts.slice(0, 6).map(p => [p.lat, p.lon])));
          log('GPX импортирован (WP1..WP5 и END).');
        } catch (e) {
          log('Ошибка импорта GPX: ' + e.message);
        }
      };
      reader.readAsText(f);
    }

    function connectRos() {
      const url = document.getElementById('rosUrl').value.trim();
      if (!url) return;
      disconnectRos();

      try {
        socket = new WebSocket(url);
      } catch (e) {
        log('Ошибка WebSocket: ' + e.message);
        return;
      }

      socket.onopen = () => {
        setTopStatus('Подключено');
        log('ROS Bridge подключен.');
        subscribeTopics();
      };

      socket.onclose = () => {
        setTopStatus('Отключено');
        log('Соединение закрыто.');
      };

      socket.onerror = () => log('Ошибка WebSocket.');

      socket.onmessage = (e) => {
        let d;
        try { d = JSON.parse(e.data); } catch { return; }

        if (d.topic === '/mavros/global_position/global') {
          const m = d.msg;
          state.currentGps = { lat: +m.latitude, lon: +m.longitude, alt: +m.altitude };
          state.lastGpsFixTimestamp = Date.now();
          refreshTelemetryBox();
        }

        if (d.topic === '/mavros/global_position/raw/fix') {
          const s = d.msg && d.msg.status ? d.msg.status.status : null;
          state.gpsFixStatus = s;
          if (typeof s === 'number' && s < 0) {
            onGpsLost('GPS status < 0');
          }
          refreshTelemetryBox();
        }

        if (d.topic === '/mavros/state') {
          state.flightMode = d.msg.mode || '—';
          refreshTelemetryBox();
        }
      };
    }

    function disconnectRos() {
      if (socket) {
        try { socket.close(); } catch (_) {}
      }
      socket = null;
      setTopStatus('Отключено');
    }

    function sendRos(obj) {
      if (!socket || socket.readyState !== WebSocket.OPEN) throw new Error('Нет подключения к ROS Bridge');
      socket.send(JSON.stringify(obj));
    }

    function subscribeTopics() {
      ['/mavros/global_position/global', '/mavros/global_position/raw/fix', '/mavros/state'].forEach(t => {
        sendRos({ op: 'subscribe', topic: t });
      });
    }

    function callService(service, args) {
      sendRos({ op: 'call_service', service, args: args || {} });
    }

    function setManualMode() {
      try {
        callService('/release', {});
        callService('/mavros/set_mode', { custom_mode: 'POSITION' });
      } catch (e) {
        log('Не удалось перейти в ручное/position: ' + e.message);
      }
    }

    function onGpsLost(reason) {
      if (!state.mission.running) return;
      stopMission(`Потеря GPS: ${reason}`);
      setManualMode();
      alert('Потеря GPS! Миссия остановлена. Переход на ручное управление.');
    }

    setInterval(() => {
      if (!state.mission.running) return;
      const staleMs = Date.now() - state.lastGpsFixTimestamp;
      if (!state.lastGpsFixTimestamp || staleMs > 5000) {
        onGpsLost('нет обновления GPS > 5 сек');
      }
    }, 1000);

    function haversineMeters(a, b) {
      const R = 6371000;
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const la1 = toRad(a.lat), la2 = toRad(b.lat);
      const x = Math.sin(dLat/2) ** 2 + Math.cos(la1) * Math.cos(la2) * Math.sin(dLon/2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(x), Math.sqrt(1 - x));
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function waitUntilReached(target, targetAlt, timeoutSec = 240) {
      const start = Date.now();
      while (true) {
        if (state.mission.stopRequested) throw new Error('Mission stopped');
        if (!state.currentGps) { await sleep(500); continue; }

        const hDist = haversineMeters(state.currentGps, target);
        const vDist = Math.abs((state.currentGps.alt || 0) - targetAlt);

        if (hDist < 2.5 && vDist < 2.0) return;
        if ((Date.now() - start) / 1000 > timeoutSec) throw new Error('Timeout ожидания точки');
        await sleep(700);
      }
    }

    function navigateGlobal(lat, lon, alt, speed, autoArm = false) {
      callService('/navigate_global', {
        lat, lon, z: alt, speed,
        yaw: 0,
        auto_arm: !!autoArm
      });
    }

    function validateMissionInputs() {
      if (!socket || socket.readyState !== WebSocket.OPEN) throw new Error('Сначала подключитесь к ROS Bridge');
      if (state.waypoints.length !== 5 || !state.endPoint) {
        throw new Error('Нужно задать 5 промежуточных точек и 1 конечную');
      }
      if (!state.currentGps) throw new Error('Нет GPS координат от дрона');
    }

    async function runMission() {
      validateMissionInputs();

      const cruiseAlt = parseFloat(document.getElementById('cruiseAlt').value);
      const cruiseSpeed = parseFloat(document.getElementById('cruiseSpeed').value);
      const descentAlt = parseFloat(document.getElementById('descentAlt').value);
      const descentSpeed = parseFloat(document.getElementById('descentSpeed').value);
      const endAction = document.getElementById('endAction').value;
      const afterReturn = document.getElementById('afterReturn').value;

      if ([cruiseAlt, cruiseSpeed, descentAlt, descentSpeed].some(v => Number.isNaN(v) || v <= 0)) {
        throw new Error('Проверьте высоты и скорости');
      }

      state.mission.running = true;
      state.mission.stopRequested = false;

      try {
        state.mission.step = 'takeoff+route';
        refreshTelemetryBox();
        log('Старт миссии: взлёт и проход WP1..WP5');

        for (let i = 0; i < state.waypoints.length; i++) {
          const wp = state.waypoints[i];
          const autoArm = i === 0;
          navigateGlobal(wp.lat, wp.lon, cruiseAlt, cruiseSpeed, autoArm);
          log(`Команда на WP${i+1}: alt=${cruiseAlt}, speed=${cruiseSpeed}`);
          await waitUntilReached(wp, cruiseAlt);
          log(`Достигнута WP${i+1}`);
        }

        state.mission.step = 'final-descend';
        refreshTelemetryBox();
        navigateGlobal(state.endPoint.lat, state.endPoint.lon, descentAlt, descentSpeed, false);
        log(`Переход к END со снижением: alt=${descentAlt}, speed=${descentSpeed}`);
        await waitUntilReached(state.endPoint, descentAlt);
        log('Достигнута END (снижение выполнено).');

        if (endAction === 'manual_stop') {
          state.mission.step = 'manual-transfer';
          refreshTelemetryBox();
          log('Действие END: переход на ручное управление, миссия завершена.');
          setManualMode();
          return;
        }

        state.mission.step = 'wait-operator';
        state.mission.waitingOperator = true;
        refreshTelemetryBox();
        log('Команда оператору: выполнить сброс. Нажмите "Продолжить после действия оператора".');
        await new Promise((resolve, reject) => {
          state.mission.operatorContinueResolver = resolve;
          const watcher = setInterval(() => {
            if (state.mission.stopRequested) {
              clearInterval(watcher);
              reject(new Error('Mission stopped'));
            }
          }, 300);
        });
        state.mission.waitingOperator = false;

        state.mission.step = 'return-path';
        refreshTelemetryBox();
        log('Возврат по обратному пути WP5..WP1.');
        const back = [...state.waypoints].reverse();
        for (let i = 0; i < back.length; i++) {
          const p = back[i];
          navigateGlobal(p.lat, p.lon, cruiseAlt, cruiseSpeed, false);
          log(`Возврат к WP${5-i}`);
          await waitUntilReached(p, cruiseAlt);
        }

        if (afterReturn === 'land') {
          state.mission.step = 'landing';
          refreshTelemetryBox();
          log('После возврата: посадка.');
          callService('/land', {});
        } else {
          log('После возврата: зависание в последней точке.');
        }

        state.mission.step = 'completed';
        refreshTelemetryBox();
        log('Миссия завершена.');
      } finally {
        state.mission.running = false;
        state.mission.stopRequested = false;
        state.mission.waitingOperator = false;
        state.mission.operatorContinueResolver = null;
        if (state.mission.step !== 'completed') {
          state.mission.step = 'idle';
          refreshTelemetryBox();
        }
      }
    }

    async function startMission() {
      if (state.mission.running) {
        log('Миссия уже выполняется.');
        return;
      }
      try {
        await runMission();
      } catch (e) {
        log('Ошибка миссии: ' + e.message);
      }
    }

    function stopMission(reason) {
      if (!state.mission.running) {
        log('Миссия не запущена.');
        return;
      }
      state.mission.stopRequested = true;
      state.mission.step = 'stopping';
      refreshTelemetryBox();
      log(reason || 'Стоп миссии');
      setManualMode();
    }

    function continueAfterOperatorAction() {
      if (!state.mission.waitingOperator || !state.mission.operatorContinueResolver) {
        log('Сейчас нет ожидания действия оператора.');
        return;
      }
      const resolver = state.mission.operatorContinueResolver;
      state.mission.operatorContinueResolver = null;
      resolver();
      log('Подтверждение оператора получено. Продолжаем миссию.');
    }

    function emergencyLand() {
      try {
        state.mission.stopRequested = true;
        callService('/land', {});
        log('Аварийная посадка отправлена.');
      } catch (e) {
        log('Ошибка аварийной посадки: ' + e.message);
      }
    }

    initMap();
    refreshTelemetryBox();
  </script>
</body>
</html>